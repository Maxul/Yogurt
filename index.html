<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8" />
    <title>Yet Another Functional Programming Interpreter</title>
    <script src="https://cdn.jsdelivr.net/npm/jquery"></script>
    <script src="https://cdn.jsdelivr.net/gh/jcubic/static/js/wcwidth.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery.terminal/js/jquery.terminal.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery.terminal/js/xml_formatting.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-polyfills/keyboard.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-lolcat/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/figlet/lib/figlet.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/jquery.terminal/css/jquery.terminal.min.css" rel="stylesheet" />
    <style>
        :root {
            --color: #aaa;
            --background: #000;
            --size: 1.2;
            --font: monospace;
            /* --glow: 1 */
            --animation: terminal-blink;
        }

        .command {
            cursor: pointer;
        }

        @media screen and (min-width: 1200px) {
            :root {
                --size: 1.4;
            }
        }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>

<body>
    <script>
        // utils.js

        const keywords = [
            "if", "then", "else", // branch
            "not", "and", "or",   // logical
            "while", "for", "in", // loop
        ];

        const suffix_ops = "<>=!:";
        const brackets = "()[]{}";

        const constants = {
            pi: Math.PI,
            e: Math.E,
            epsilon: Number.EPSILON,
            true: true,
            false: false,
            null: null,
        };

        const native_functions = {
            sin: Math.sin,
            cos: Math.cos,
            tan: Math.tan,
            ceil: Math.ceil,
            floor: Math.floor,
            round: Math.round,
            log: Math.log,
            exp: Math.exp,
            pow: Math.pow,
            sqrt: Math.sqrt,
            abs: Math.abs,
            max: Math.max,
            min: Math.min,
            random: Math.random,
        };

        // scope.js

        const Scope = {
            env_stack: [{}],
            depth: 0,

            env: function () {
                return this.env_stack[this.depth];
            },

            push: function () {
                var parent = this.env_stack[this.depth];
                var new_scope = Object.create(parent);
                this.env_stack.push(new_scope);
                this.depth += 1;
            },

            pop: function () {
                if (this.depth == 0) throw "Stack is empty";
                this.env_stack.pop();
                this.depth -= 1;
            },
        };

        // memo.js

        ////////// function return value memory database //////////
        const Memo = {

            // [ {func: name, args: [], ret: value}, ... ]
            memoization: [],

            makeMemoString: function (args) {
                var ret = "";

                for (var i in args)
                    ret += String(args[i]) + ' ';
                return ret;
            },

            getMemoValue: function (func, args) {
                var key = this.makeMemoString(args);
                if (this.memoization[func])
                    return this.memoization[func][key];
                return undefined;
            },

            setMemoValue: function (func, args, val) {
                if ("undefined" === typeof this.memoization[func])
                    this.memoization[func] = [];

                var key = this.makeMemoString(args);
                this.memoization[func][key] = val;
            },

            clearMemoRow: function (func) {
                if ("undefined" !== typeof this.memoization[func])
                    this.memoization[func] = [];
            },
        };

        // lex.js

        /*
         * lexer: tokenize input stream into lexemes list
         */
        function tequila_lex(input) {
            var token_list = [];
            var index = 0;

            var ch;                     /* current character */

            // private methods using regular expressions
            function isSpace(c) { return /\s/.test(c); }
            function isDigit(c) { return /[\d\.]/.test(c); }
            function isOp(c) { return /[\+\-\*\/\(\)\,\=\<\>\!\:\;\[\]\{\}]/.test(c); }
            function isId(c) { return "string" === typeof c && !isOp(c) && !isSpace(c); }

            // read a character once from stream buffer
            function advance() { return ch = input[++index]; }
            function addToken(t) { token_list.push(t); }
            function isKeyWord(t) { return keywords.indexOf(t) >= 0; }

            function getToken() {
                if (index >= input.length)
                    return null;

                ch = input[index];      // getChar()
                while (isSpace(ch))     // skip all whitespaces
                    ch = advance();

                if (isOp(ch)) {
                    var ret = ch;
                    var t = ch;

                    advance();
                    if (brackets.indexOf(t) >= 0)
                        return { node: ret };
                    // compound operator
                    for (; ;) {
                        t = input[index];
                        if (suffix_ops.indexOf(t) < 0)
                            break;
                        ret += t;
                        advance();
                    }
                    return { node: ret };
                }

                if (ch === '"' || ch === "'") {
                    var quote = ch;
                    var string = "";
                    advance(); // skip head "\""
                    while (input[index] !== quote && index < input.length) {
                        string += input[index];
                        advance();
                    }
                    advance(); // skip tail "\""
                    return { "node": "string", "value": string };
                }

                if (isDigit(ch)) {
                    var num = ch;

                    do {
                        advance();
                        num += ch;
                    } while (isDigit(ch));

                    num = parseFloat(num);
                    if (!isFinite(num))
                        throw "Number is too large or too small for a 64-bit floating-point.";
                    return { node: "num", value: num };
                }

                // can be either variables or subroutines
                if (isId(ch)) {
                    var id = ch;

                    while (isId(advance()))
                        id += ch;

                    // keywords is prior to user defined identifiers
                    if (isKeyWord(id))
                        return { node: id };
                    return { node: "id", value: id };
                }

                throw "Unrecognized token.";
            }

            while (token = getToken())
                addToken(token);

            addToken({ node: "EOF" });           /* no more tokens */
            console.log(JSON.stringify(token_list));
            return token_list;
        }

        // parse.js

        /*
         * parser: construct a parse tree according to token list
         */
        function tequila_parse(token_list) {
            var tokTable = {};      // ready to get referenced for all possible symbols

            function getNextToken() { return token_list.shift(); }

            // duplicate one from token list, deep cloning and register callbacks
            function dupCurToken() {
                var tok = token_list[0];

                if (!tokTable[tok.node]) {
                    throw "Unrecognised token \"" + tok.node + "\"";
                }
                var newTok = Object.create(tokTable[tok.node]); // nud, lbp, led
                newTok.node = tok.node;
                newTok.value = tok.value;
                return newTok;
            }

            /*
             * Top-down operator precedence parsing
             * LR(1): shift-reduce
             *
             * @param rbp   right binding power
             */
            function expr(rbp) {
                var tok = dupCurToken();

                if (!tok.nud)
                    throw "Unexpected token: " + tok.node;

                getNextToken(); // eat id/number/prefix

                var lhs = tok.nud(tok); // mostly simply return itself
                while (rbp < dupCurToken().lbp) {
                    tok = dupCurToken();
                    getNextToken(); // eat infix
                    if (!tok.led)
                        throw "Unexpected token: " + tok.node;
                    lhs = tok.led(lhs);
                }
                //console.log(lhs);
                return lhs;
            }

            /*
             * @brief http://javascript.crockford.com/tdop/tdop.html
             * @param id Identifier
             * @param nud Null denotative
             * @param led Left denotative
             */
            function makeSymbol(id, nud, lbp, led) {
                // register symbol table
                var tok = tokTable[id] || {};
                tokTable[id] = {
                    nud: tok.nud || nud,
                    lbp: tok.lbp || lbp,
                    led: tok.led || led,
                };
            }

            makeSymbol("string", function (n) { return n.value; });

            makeSymbol(",");
            makeSymbol(";");
            makeSymbol(":");

            // for array
            makeSymbol("[", function () {
                var elems = [];
                if (token_list[0].node !== "]") {
                    while (true) {
                        elems.push(expr(0));
                        if (token_list[0].node !== ",") {
                            break;
                        }
                        getNextToken(); // eat ","
                    }
                }
                if (token_list[0].node !== "]")
                    throw "Expected closing bracket ']'";
                getNextToken(); // eat "]"
                return { "node": "array", "elements": elems };
            });
            makeSymbol("]");

            makeSymbol("for", function () {
                if ("(" !== token_list[0].node)
                    throw "Expected '(' after for";
                getNextToken(); // eat "("

                var init = expr(0);

                // case A: for n in nums
                if (init.node === "in") {
                    if (")" !== token_list[0].node)
                        throw "Expected ')' after for-in loop";
                    getNextToken(); // eat ")"

                    var body = expr(0);

                    return {
                        "node": "loop_for_in",
                        "iterator": init.lhs,   // "n"
                        "collection": init.rhs, // "nums"
                        "body": body
                    };
                }

                // case B: for (i = 0; i < N; i = i + 1)
                if (";" !== token_list[0].node)
                    throw "Expected ';' or 'in' in for loop";
                getNextToken(); // eat first ";"

                var cond = expr(0); // 解析条件 (i < 10)

                if (";" !== token_list[0].node)
                    throw "Expected ';' after condition";
                getNextToken(); // eat second ";"

                var step = expr(0);

                if (")" !== token_list[0].node)
                    throw "Expected ')' after step";
                getNextToken(); // eat ")"

                var body = expr(0);

                return {
                    "node": "loop_for",
                    "init": init,
                    "cond": cond,
                    "step": step,
                    "body": body
                };
            });

            makeSymbol("while", function () {
                var cond = expr(0);
                var body = expr(0);
                return { "node": "loop_while", "cond": cond, "body": body };
            });

            makeSymbol("if", function () {
                var cond = expr(0);
                if ("then" !== token_list[0].node)
                    throw "Expected 'then' clause";
                getNextToken(); // eat "then"

                var conseq = expr(0);
                if ("else" !== token_list[0].node)
                    /*throw "Expected 'else' clause";*/
                    return { "node": "branch", "cond": cond, "conseq": conseq };
                getNextToken(); // eat "else"

                var alt = expr(0);
                return { "node": "branch", "cond": cond, "conseq": conseq, "alt": alt };
            });
            makeSymbol("then");
            makeSymbol("else");

            makeSymbol("(", function () {
                var e = expr(0);

                // check if it is a tuple
                if (token_list[0].node === ",") {
                    var elems = [e];
                    while (token_list[0].node === ",") {
                        getNextToken(); // eat ","
                        if (token_list[0].node === ")") break;
                        elems.push(expr(0));
                    }
                    if (")" !== token_list[0].node)
                        throw "Expected closing parenthesis ')' for tuple";
                    getNextToken(); // eat ")"
                    return { node: "tuple", elements: elems };
                }

                if (")" !== token_list[0].node)
                    throw "Expected closing parenthesis ')'";
                getNextToken(); // eat ")"
                return e;
            });
            makeSymbol(")");

            makeSymbol('{', function () {
                // 1. handle empty dict {} 
                if ("}" === token_list[0].node) {
                    getNextToken();
                    return { "node": "dict", "pairs": [] };
                }

                var isDict = false;
                if (token_list.length > 1 && token_list[1].node === ":") {
                    isDict = true;
                }

                if (isDict) {
                    var pairs = [];
                    do {
                        var key = expr(0);
                        if (":" !== token_list[0].node)
                            throw "Expected ':' in dict definition";
                        getNextToken(); // eat ":""

                        var val = expr(0);
                        pairs.push({ key: key, val: val });

                        if ("," === token_list[0].node) {
                            getNextToken(); // eat ",""
                        } else {
                            break;
                        }
                    } while ("}" !== token_list[0].node);

                    if ("}" !== token_list[0].node) throw "Expected '}'";
                    getNextToken();
                    return { node: "dict", pairs: pairs };
                }

                var statements = [];

                while ("}" !== token_list[0].node) {
                    if (";" === token_list[0].node) {
                        getNextToken();
                        continue;
                    }

                    statements.push(expr(0));
                }
                getNextToken();     // eat "}"
                return { node: "block", stmts: statements };
            });
            makeSymbol('}');
            makeSymbol("num", function (n) { return n; });
            makeSymbol("id", function (name) {
                if ("(" !== token_list[0].node) // variable reference
                    return name;

                var args = [];                  // function call

                if (")" === token_list[1].node)
                    getNextToken(); // eat ")" since no args
                else {
                    do {
                        getNextToken(); // eat "(" and ","
                        args.push(expr(0));
                    } while ("," === token_list[0].node);
                    if (")" !== token_list[0].node)
                        throw "Expected closing parenthesis ')'";
                }
                getNextToken(); // move to new token ready to go
                return { node: "call", args: args, name: name.value };
            });
            makeSymbol("EOF");

            // wrappers
            function prefix(id, rbp) {
                makeSymbol(id, function () {
                    return { node: id, rhs: expr(rbp) };
                });
            }
            function infix(id, lbp, rbp, led) {
                rbp = rbp || lbp;
                makeSymbol(id, null, lbp, led || function (lhs) {
                    return { node: id, lhs: lhs, rhs: expr(rbp) };
                });
            }

            // install standard operators and set precedence, 1 is the lowest
            infix("[", 8, 8, function (lhs) {
                var index = expr(0);
                if ("]" !== token_list[0].node)
                    throw "Expected ']'";
                getNextToken(); // eat "]"
                return { "node": "index", "target": lhs, "index": index };
            });

            prefix("+", 7);
            prefix("-", 7);

            infix("*", 6);
            infix("/", 6);
            infix("%", 6);
            infix("+", 5);
            infix("-", 5);

            infix("<", 4);
            infix(">", 4);
            infix("<=", 4);
            infix(">=", 4);
            infix("==", 4);
            infix("!=", 4);
            infix("in", 4);

            prefix("not", 3);
            infix("and", 3);
            infix("or", 3);

            infix("=", 1, 2, function (lhs) {
                // assignment to identifier
                if ("id" === lhs.node) {
                    return { node: "assign", name: lhs.value, value: expr(0) };
                }
                if ("call" === lhs.node) {
                    // check whether each arg is valid
                    for (var i = 0; i < lhs.args.length; ++i)
                        if ("id" !== lhs.args[i].node)
                            throw "Invalid argument name";
                    return { node: "def", name: lhs.name, args: lhs.args, value: expr(0) };
                }
                throw "Invalid lvalue.";
            });
            infix(":=", 1, 2, function (lhs) {
                var name;
                var params = [];

                if (lhs.node === "id") {        // without args
                    name = lhs.value;
                }
                else if (lhs.node === "call") { // with args
                    name = lhs.name;
                    for (var i = 0; i < lhs.args.length; i++) {
                        if (lhs.args[i].node !== "id")
                            throw "Parameter name must be an identifier";
                        params.push(lhs.args[i].value);
                    }
                } else {
                    throw "Invalid lvalue for procedure definition.";
                }
                var body = expr(0);
                return { node: "proc_def", name: name, params: params, body: body };
            });
            console.log(JSON.stringify(token_list));
            var parse_tree = [];

            while ("EOF" !== token_list[0].node) {
                if (";" === token_list[0].node) {
                    getNextToken();
                    continue;
                }
                parse_tree.push(expr(0));
            }
            console.log(parse_tree.length);
            console.log(JSON.stringify(parse_tree));
            return parse_tree;
        }

        // eval.js

        /*
         * evaluate: iterate each parse node and do syntax analysis
         */
        function tequila_evaluate(parse_tree) {
            var ops = {
                // take the place of LHS with RHS when only RHS exists
                "+": function (a, b) { return "undefined" === typeof b ? +a : a + b; },
                "-": function (a, b) { return "undefined" === typeof b ? -a : a - b; },
                "*": function (a, b) { return a * b; },
                "/": function (a, b) { return a / b; },

                ">": function (a, b) { return a > b; },
                "<": function (a, b) { return a < b; },
                ">=": function (a, b) { return a >= b; },
                "<=": function (a, b) { return a <= b; },
                "==": function (a, b) { return a == b; },
                "!=": function (a, b) { return a != b; },

                "not": function (a) { return "boolean" === typeof a ? !a : null; },
                "and": function (a, b) {
                    return "boolean" === typeof a && "boolean" === typeof b ? a && b : null;
                },
                "or": function (a, b) {
                    return "boolean" === typeof a && "boolean" === typeof b ? a || b : null;
                },
                "in": function (a, b) {
                    if (Array.isArray(b)) {
                        return b.includes(a);
                    }
                    if (typeof b === 'object' && b !== null) {
                        return a in b;
                    }
                    return false;
                }
            };

            function parseTree(root) {
                if ("num" === root.node) {
                    return root.value;
                }
                else if ("id" === root.node) {
                    // is it a constant value?
                    if ("undefined" !== typeof constants[root.value])
                        return constants[root.value];

                    // may be a variable defined before
                    var val = Scope.env()[root.value];

                    if ("undefined" === typeof val)
                        throw "Variable \"" + root.value + "\" is undefined!!!";
                    return val;
                }
                else if (ops[root.node]) {
                    if (root.lhs)       // if this is a binary operator
                        return ops[root.node](parseTree(root.lhs), parseTree(root.rhs));
                    else                // or it is a unary one, lhs is a nil
                        return ops[root.node](parseTree(root.rhs));
                }
                else if ("assign" === root.node) {
                    // constants cannot be re-defined
                    if ("undefined" !== typeof constants[root.name])
                        throw "Constant \"" + root.name + "\" has already been defined";

                    // push a value bound to a name into the current environment
                    var val = parseTree(root.value);
                    var currentScope = Scope.env();

                    // use parent's if it exists, otherwise define local
                    var scopeCursor = currentScope;
                    var found = false;

                    while (scopeCursor && scopeCursor !== Object.prototype) {
                        if (Object.prototype.hasOwnProperty.call(scopeCursor, root.name)) {
                            scopeCursor[root.name] = val;
                            found = true;
                            break;
                        }
                        scopeCursor = Object.getPrototypeOf(scopeCursor);
                    }

                    if (!found) {
                        currentScope[root.name] = val; // new variable only local
                    }

                    return val;
                }
                else if ("def" === root.node) {
                    // clear previous definition
                    Memo.clearMemoRow(root.name);
                    // push a definition bound to a prototype into environment
                    var paramNames = [];
                    for (var i = 0; i < root.args.length; i++) {
                        paramNames.push(root.args[i].value);
                    }

                    Scope.env()[root.name] = {
                        type: "func",
                        params: paramNames,
                        body: root.value
                    };
                    return "Function " + root.name + "() defined";
                }
                else if ("call" === root.node) {
                    // is it a function provided by us?
                    if ("function" === typeof native_functions[root.name]) {
                        var nativeArgs = [];
                        for (var i = 0; i < root.args.length; ++i)
                            nativeArgs.push(parseTree(root.args[i]));
                        return native_functions[root.name].apply(null, nativeArgs);
                    }

                    var funcDef = Scope.env()[root.name];
                    if ("undefined" === typeof funcDef)
                        throw "Function \"" + root.name + "\" is undefined";

                    if (root.args.length !== funcDef.params.length) {
                        throw "Function '" + root.name + "' expects " +
                        funcDef.params.length + " arguments, got " + root.args.length;
                    }

                    var argValues = [];
                    for (var i = 0; i < root.args.length; ++i) {
                        argValues.push(parseTree(root.args[i]));
                    }

                    var memoKey = Memo.makeMemoString(argValues);

                    Scope.push();

                    for (var i = 0; i < funcDef.params.length; ++i) {
                        var paramName = funcDef.params[i];
                        Scope.env()[paramName] = argValues[i];
                    }

                    var result;
                    try {
                        result = parseTree(funcDef.body);
                    } finally {
                        Scope.pop();
                    }

                    return result;
                }
                else if ("branch" == root.node) {
                    var c = parseTree(root.cond);

                    if ("boolean" !== typeof c)
                        throw "Expected a boolean expression.";
                    if (c)
                        return parseTree(root.conseq);
                    else
                        if (root.alt)
                            return parseTree(root.alt);
                }
                else if ("block" === root.node) {
                    var ss = root.stmts;

                    Scope.push();   // enter block
                    // iterate each statement and evaluate the node
                    var result = null;
                    for (var i = 0; i < ss.length; ++i)
                        result = parseTree(ss[i]);
                    Scope.pop();    // exit block
                    return result;
                }
                else if ("loop_for" === root.node) {
                    Scope.push();
                    parseTree(root.init);
                    var lastResult = null;
                    while (true) {
                        var condition = parseTree(root.cond);
                        if (!condition) break;
                        lastResult = parseTree(root.body);
                        parseTree(root.step);
                    }
                    Scope.pop();
                    return lastResult;
                }
                else if ("loop_for_in" === root.node) {
                    var collection = parseTree(root.collection);

                    if (!Array.isArray(collection)) throw "For-in loop expects an array.";

                    Scope.push();
                    var lastResult = null;
                    var varName = root.iterator.value;
                    for (var i = 0; i < collection.length; i++) {
                        Scope.env()[varName] = collection[i];
                        lastResult = parseTree(root.body);
                    }
                    Scope.pop();
                    return lastResult;
                }
                else if ("loop_while" === root.node) {
                    Scope.push();
                    var ret = null;
                    while (parseTree(root.cond)) {
                        ret = parseTree(root.body);
                    }
                    Scope.pop();
                    return ret;
                }
                else if ("array" === root.node) {
                    var result = [];
                    for (var i = 0; i < root.elements.length; ++i) {
                        result.push(parseTree(root.elements[i]));
                    }
                    return result;
                }
                else if ("tuple" === root.node) {
                    var res = [];
                    for (var i = 0; i < root.elements.length; ++i)
                        res.push(parseTree(root.elements[i]));
                    return res;
                }
                else if ("dict" === root.node) {
                    var res = {};
                    for (var i = 0; i < root.pairs.length; ++i) {
                        var pair = root.pairs[i];
                        var keyRaw = pair.key;
                        var keyName;

                        if (keyRaw.node === "id") keyName = keyRaw.value;
                        else if (keyRaw.node === "num") keyName = keyRaw.value;
                        else keyName = parseTree(keyRaw);

                        var val = parseTree(pair.val);
                        res[keyName] = val;
                    }
                    return res;
                }
                else if ("index" === root.node) {
                    // obj[key]
                    var target = parseTree(root.target);
                    var idx = parseTree(root.index);

                    if (target === undefined || target === null)
                        throw "Cannot index null or undefined";

                    return target[idx];
                }
                else if ("proc_def" === root.node) {
                    Scope.env()[root.name] = { type: "proc", params: root.params, body: root.body };
                    return "Procedure " + root.name + "() defined";
                }
                return "nil";       // unhandled exception
            }

            // main process of evaluating parse node
            var output = [];

            for (var i = 0; i < parse_tree.length; ++i)
                output.push(String(parseTree(parse_tree[i])));
            return output;
        }

        const font = 'Slant';

        figlet.defaults({ fontPath: 'https://cdn.jsdelivr.net/npm/figlet/fonts' });
        figlet.preloadFonts([font], ready);

        const formatter = new Intl.ListFormat('en', {
            style: 'long',
            type: 'conjunction',
        });

        const commands = {
            echo(...args) {
                this.echo(args.join(' '));
            },
            help() {
                this.echo(`List of available commands: ${help}`);
            },
            yogurt() {
                term.push(function (command, term) {
                    try {
                        console.time("ticks");
                        var tmp, ret = [];

                        var input_stream = command.trim();
                        var token_list = tequila_lex(input_stream);
                        var parse_tree = tequila_parse(token_list);
                        var result_array = tequila_evaluate(parse_tree);
                        console.log(JSON.stringify(result_array));
                        while (tmp = result_array.shift())
                            if ("undefined" !== tmp)
                                ret.push(tmp);

                        // only return the value evaluated from last statement
                        term.echo("=> " + ret[ret.length - 1]);
                        console.timeEnd("ticks");
                    } catch (err) {
                        term.error(String(err));
                    }
                }, {
                    greetings: 'Yet Another Interpreter',
                    name: "Tequila",
                    prompt: ">> ",
                });
            }
        };

        const command_list = ['clear'].concat(Object.keys(commands));
        const formatted_list = command_list.map(cmd => `<white class="command">${cmd}</white>`);
        const help = formatter.format(formatted_list);

        const term = $('body').terminal(commands, {
            completion: true,
            checkArity: true,
            greetings: false
        });

        term.on('click', '.command', function () {
            const command = $(this).text();
            term.exec(command, { typing: true, delay: 50 });
        });

        function ready() {
            const seed = rand(256);
            term.echo(() => rainbow(render('Yogurt Interpreter'), seed)).resume();
        }

        function rainbow(string, seed) {
            return lolcat.rainbow(function (char, color) {
                char = $.terminal.escape_brackets(char);
                return `[[;${hex(color)};]${char}]`;
            }, string, seed).join('\n');
        }

        function rand(max) {
            return Math.floor(Math.random() * (max + 1));
        }

        function render(text) {
            const cols = term.cols();
            return trim(figlet.textSync(text, {
                font: font,
                width: cols,
                whitespaceBreak: true
            }));
        }

        function trim(str) {
            return str.replace(/[\n\s]+$/, '');
        }

        function hex(color) {
            return '#' + [color.red, color.green, color.blue].map(n => {
                return n.toString(16).padStart(2, '0');
            }).join('');
        }
    </script>
</body>

</html>